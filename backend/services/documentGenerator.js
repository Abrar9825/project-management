/**
 * AI DOCUMENT GENERATOR ENGINE
 * Generates all documents using OpenRouter AI (GPT)
 * Falls back to structured templates if AI is unavailable
 */

const Project = require('../models/Project.model');
const Document = require('../models/Document.model');
const { ClientPayment } = require('../models/Payment.model');
const Task = require('../models/Task.model');
const TimeLog = require('../models/TimeLog.model');
const Feedback = require('../models/Feedback.model');
const { Activity } = require('../models/Activity.model');
const AIService = require('./aiService');

class DocumentGenerator {

    // ==================== HELPER: Collect project context for AI ====================
    static async _getProjectContext(project) {
        const payments = await ClientPayment.find({ project: project._id }).lean();
        const tasks = await Task.find({ project: project._id }).select('title status priority assignedTo stage').lean();
        const timeLogs = await TimeLog.find({ project: project._id }).lean();

        const totalHours = timeLogs.reduce((s, t) => s + (t.hours || 0), 0);
        const totalReceived = payments.filter(p => p.status === 'received').reduce((s, p) => s + p.amount, 0);
        const totalPending = payments.filter(p => p.status === 'pending').reduce((s, p) => s + p.amount, 0);

        return {
            projectName: project.name,
            description: project.description,
            type: project.type,
            status: project.status,
            mode: project.mode,
            priority: project.priority,
            health: project.health,
            progress: project.progress,
            startDate: project.startDate,
            dueDate: project.dueDate,
            totalAmount: project.totalAmount,
            advancePercent: project.advancePercent,
            scopeOfWork: project.scopeOfWork || project.description,
            deliverables: project.deliverables || [],
            paymentTerms: project.paymentTerms || '',
            paymentMedium: project.paymentMedium || 'bank-transfer',
            latePaymentPolicy: project.latePaymentPolicy || 'Payment overdue by 7 days results in project pause.',
            clientDetails: {
                name: project.clientDetails?.name || project.client,
                company: project.clientDetails?.company || '',
                email: project.clientDetails?.email || project.clientAccess?.clientEmail || '',
                phone: project.clientDetails?.phone || project.clientAccess?.clientPhone || '',
                address: project.clientDetails?.address || '',
                contactPerson: project.clientDetails?.contactPerson || project.client
            },
            communicationChannels: project.communicationChannels || {},
            stages: (project.stages || []).map(s => ({
                name: s.name,
                status: s.status,
                order: s.order,
                deadline: s.deadline,
                completionRate: s.completionRate
            })),
            milestonesData: project.milestonesData || [],
            responsibilities: project.responsibilities || { agency: [], client: [] },
            terminationClause: project.terminationClause || '',
            confidentialityClause: project.confidentialityClause || '',
            payments: payments.map(p => ({ label: p.label, amount: p.amount, status: p.status, date: p.date })),
            paymentSummary: { total: project.totalAmount, received: totalReceived, pending: totalPending },
            tasks: tasks.map(t => ({ title: t.title, status: t.status, priority: t.priority, stage: t.stage })),
            totalHoursLogged: totalHours,
            team: (project.team || []).map(m => ({
                name: m.name || 'Team Member',
                role: m.role || 'Developer'
            })),
            clientAccess: project.clientAccess || {}
        };
    }

    // ==================== HELPER: Save document + log activity ====================
    static async _saveDoc(project, user, type, content, icon, stage = '') {
        // Inject dynamic client info and KINNOVANCE branding into every document
        if (typeof content === 'object' && content !== null) {
            content.companyName = 'KINNOVANCE';
            content.companyLogo = '/images/logo.svg';
            content.footer = 'This document is generated by KINNOVANCE. Confidential — For authorized use only.';
            // Ensure client details are always present
            if (!content.clientInfo) {
                content.clientInfo = {
                    name: project.clientDetails?.name || project.client || '',
                    company: project.clientDetails?.company || '',
                    email: project.clientDetails?.email || project.clientAccess?.clientEmail || '',
                    phone: project.clientDetails?.phone || project.clientAccess?.clientPhone || ''
                };
            }
        }

        const doc = await Document.create({
            project: project._id,
            projectName: project.name,
            type: type,
            title: content.title || (type + ' - ' + project.name),
            status: 'final',
            content: JSON.stringify(content),
            stage: stage || (project.stages && project.stages[0] ? project.stages[0].name : ''),
            generatedBy: user._id || user.id,
            generatedByName: user.name
        });

        await Activity.create({
            project: project._id,
            user: user._id || user.id,
            userName: user.name,
            action: 'AI-Generated ' + (content.title || type),
            icon: icon,
            type: 'general'
        });

        return doc;
    }

    // ==================== CORE: AI Generate with template fallback ====================
    static async _aiGenerate(docType, docLabel, projectContext, templateFn) {
        // Try AI first
        const aiContent = await AIService.generateDocument(docLabel, projectContext);
        if (aiContent) {
            console.log('[DocGen] AI generated: ' + docLabel);
            return aiContent;
        }

        // Fallback to template
        console.log('[DocGen] AI unavailable, using template for: ' + docLabel);
        return templateFn(projectContext);
    }

    // ==================== 1. CONTRACT AGREEMENT ====================
    static async generateContract(project, user) {
        const ctx = await this._getProjectContext(project);

        const content = await this._aiGenerate('contract', 'Contract Agreement', ctx, (data) => ({
            title: 'Contract Agreement - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: data.description || data.scopeOfWork || 'Project contract agreement',
            companyName: 'KINNOVANCE',
            sections: {
                parties: {
                    agency: { name: 'KINNOVANCE', role: 'Service Provider' },
                    client: { name: data.clientDetails.name, company: data.clientDetails.company, email: data.clientDetails.email, phone: data.clientDetails.phone }
                },
                scopeOfWork: { description: data.scopeOfWork, projectType: data.type, deliverables: data.deliverables },
                timeline: { startDate: data.startDate, endDate: data.dueDate, stages: data.stages, milestones: data.milestonesData },
                paymentStructure: {
                    totalAmount: data.totalAmount, advancePercent: data.advancePercent,
                    advanceAmount: Math.round(data.totalAmount * data.advancePercent / 100),
                    paymentMedium: data.paymentMedium, paymentTerms: data.paymentTerms,
                    latePaymentPolicy: data.latePaymentPolicy, milestones: data.payments
                },
                responsibilities: {
                    agency: data.responsibilities.agency && data.responsibilities.agency.length ? data.responsibilities.agency : ['Deliver project as per scope', 'Provide regular updates', 'Maintain quality standards', 'Post-delivery support'],
                    client: data.responsibilities.client && data.responsibilities.client.length ? data.responsibilities.client : ['Provide timely feedback', 'Supply required assets', 'Make payments on schedule', 'Designate point of contact']
                },
                terminationClause: data.terminationClause || 'Either party may terminate with 30 days notice. Completed work is non-refundable.',
                confidentiality: data.confidentialityClause || 'Both parties agree to maintain confidentiality of all shared information.',
                signatures: { agency: { name: 'Agency Representative', date: '', signature: '' }, client: { name: data.clientDetails.contactPerson, date: '', signature: '' } }
            }
        }));

        return this._saveDoc(project, user, 'contract', content, '📝', 'Requirement');
    }

    // ==================== 2. WELCOME DOCUMENT ====================
    static async generateWelcomeDoc(project, user) {
        const ctx = await this._getProjectContext(project);

        const content = await this._aiGenerate('welcome-doc', 'Welcome Document', ctx, (data) => ({
            title: 'Welcome Document - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: data.description || 'Welcome to your project journey with KINNOVANCE',
            companyName: 'KINNOVANCE',
            sections: {
                introduction: {
                    greeting: 'Welcome aboard, ' + data.clientDetails.name + '!',
                    message: 'We at KINNOVANCE are thrilled to begin working on ' + data.projectName + '. ' + (data.description || '') + ' This document provides everything you need to know about our collaboration.'
                },
                projectOverview: { name: data.projectName, description: data.description, type: data.type, startDate: data.startDate, dueDate: data.dueDate, totalStages: data.stages.length },
                timeline: data.stages.map(s => ({ stage: s.name, deadline: s.deadline, order: s.order })),
                communicationChannels: {
                    primary: data.communicationChannels.primary || 'Email / WhatsApp',
                    meetingSchedule: data.communicationChannels.meetingSchedule || 'Weekly check-in calls',
                    supportEmail: data.communicationChannels.supportEmail || 'support@agency.com',
                    supportPhone: data.communicationChannels.supportPhone || ''
                },
                teamIntro: data.team.map(m => ({ name: m.name, role: m.role })),
                nextSteps: ['Project kickoff meeting', 'Requirement finalization', 'Design mockups delivery', 'Regular progress updates']
            }
        }));

        return this._saveDoc(project, user, 'welcome-doc', content, '🎉', 'Requirement');
    }

    // ==================== 3. PAYMENT PLAN ====================
    static async generatePaymentPlan(project, user) {
        const ctx = await this._getProjectContext(project);

        const content = await this._aiGenerate('payment-plan', 'Payment Plan', ctx, (data) => ({
            title: 'Payment Plan - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: 'Payment plan for ' + data.projectName + '. ' + (data.description || ''),
            companyName: 'KINNOVANCE',
            sections: {
                projectValue: { totalAmount: data.totalAmount, currency: 'INR (₹)' },
                advancePayment: { percentage: data.advancePercent, amount: Math.round(data.totalAmount * data.advancePercent / 100), dueOnSigning: true },
                paymentSchedule: data.payments.map(p => ({ label: p.label, amount: p.amount, dueDate: p.date, status: p.status })),
                paymentMethods: { preferred: data.paymentMedium, options: ['Bank Transfer', 'UPI', 'PayPal', 'Stripe'] },
                paymentTerms: data.paymentTerms || 'Net 7 days from invoice date',
                latePaymentPolicy: data.latePaymentPolicy,
                paymentOverview: { totalAmount: data.totalAmount, received: data.paymentSummary.received, pending: data.paymentSummary.pending, remainingPercent: Math.round((data.paymentSummary.pending / data.totalAmount) * 100) }
            }
        }));

        return this._saveDoc(project, user, 'payment-plan', content, '💰');
    }

    // ==================== 4. CLIENT ACCESS SHEET ====================
    static async generateClientAccessSheet(project, user) {
        const ctx = await this._getProjectContext(project);

        const content = await this._aiGenerate('client-access-sheet', 'Client Access Sheet', ctx, (data) => ({
            title: 'Client Access Sheet - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: 'Client access details for ' + data.projectName + '. ' + (data.description || ''),
            companyName: 'KINNOVANCE',
            sections: {
                clientInfo: { name: data.clientDetails.name, email: data.clientDetails.email, phone: data.clientDetails.phone, company: data.clientDetails.company },
                portalAccess: { url: '/client-portal', loginEmail: data.clientDetails.email, note: 'Use your registered email' },
                projectDashboard: { canView: ['Project progress', 'Stage status', 'Payment history', 'Shared documents', 'Meeting schedule'], canDo: ['Submit feedback', 'Upload assets', 'View documents', 'Join meetings'], cannotAccess: ['Internal tasks', 'Developer payments', 'Internal notes', 'Team chat'] },
                communicationChannels: data.communicationChannels,
                supportInfo: { email: data.communicationChannels.supportEmail || 'support@agency.com', phone: data.communicationChannels.supportPhone || '', hours: 'Mon-Fri 9AM-6PM' }
            }
        }));

        return this._saveDoc(project, user, 'client-access-sheet', content, '🔐');
    }

    // ==================== 5. FULFILLMENT PLAN ====================
    static async generateFulfillmentPlan(project, user) {
        const ctx = await this._getProjectContext(project);

        const content = await this._aiGenerate('fulfillment-plan', 'Fulfillment Plan', ctx, (data) => ({
            title: 'Fulfillment Plan - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: 'Fulfillment plan for ' + data.projectName + '. ' + (data.description || ''),
            companyName: 'KINNOVANCE',
            sections: {
                projectScope: { name: data.projectName, type: data.type, description: data.scopeOfWork },
                deliverables: data.deliverables.length ? data.deliverables : data.stages.map(s => ({ title: s.name + ' Deliverables', stage: s.name, description: 'Complete all tasks for ' + s.name + ' stage' })),
                stageBreakdown: data.stages.map(s => {
                    const stageTasks = data.tasks.filter(t => t.stage === s.name);
                    return { stageName: s.name, status: s.status, deadline: s.deadline, completion: s.completionRate || 0, totalTasks: stageTasks.length, taskBreakdown: { completed: stageTasks.filter(t => t.status === 'completed').length, inProgress: stageTasks.filter(t => t.status === 'in-progress').length, pending: stageTasks.filter(t => t.status === 'pending').length } };
                }),
                teamAllocation: data.team,
                qualityChecklist: ['Code review completed', 'Testing passed', 'Client approval received', 'Documentation updated', 'Assets delivered']
            }
        }));

        return this._saveDoc(project, user, 'fulfillment-plan', content, '📋');
    }

    // ==================== 6. TRACKING SHEET ====================
    static async generateTrackingSheet(project, user) {
        const ctx = await this._getProjectContext(project);

        const content = await this._aiGenerate('tracking-sheet', 'Project Tracking Sheet', ctx, (data) => ({
            title: 'Tracking Sheet - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: 'Project tracking for ' + data.projectName + '. ' + (data.description || ''),
            companyName: 'KINNOVANCE',
            sections: {
                projectHealth: { status: data.status, health: data.health, mode: data.mode, overallProgress: data.progress },
                timelineTracker: data.stages.map(s => ({ stage: s.name, status: s.status, deadline: s.deadline, completion: s.completionRate || 0 })),
                taskSummary: {
                    total: data.tasks.length,
                    completed: data.tasks.filter(t => t.status === 'completed').length,
                    inProgress: data.tasks.filter(t => t.status === 'in-progress').length,
                    pending: data.tasks.filter(t => t.status === 'pending').length,
                    blocked: data.tasks.filter(t => t.status === 'blocked').length
                },
                paymentTracker: { total: data.totalAmount, received: data.paymentSummary.received, pending: data.paymentSummary.pending, payments: data.payments },
                hoursLogged: data.totalHoursLogged,
                clientActions: { pendingApprovals: data.stages.filter(s => s.status === 'review').length, pendingPayments: data.payments.filter(p => p.status === 'pending').length }
            }
        }));

        return this._saveDoc(project, user, 'tracking-sheet', content, '📊');
    }

    // ==================== 7. MONTHLY REPORT ====================
    static async generateMonthlyReport(project, user, month, year) {
        const ctx = await this._getProjectContext(project);
        const now = new Date();
        const reportMonth = month || now.getMonth() + 1;
        const reportYear = year || now.getFullYear();
        const monthName = new Date(reportYear, reportMonth - 1).toLocaleString('en-US', { month: 'long' });

        ctx.reportMonth = monthName;
        ctx.reportYear = reportYear;

        const content = await this._aiGenerate('monthly-report', 'Monthly Report - ' + monthName + ' ' + reportYear, ctx, (data) => ({
            title: 'Monthly Report - ' + monthName + ' ' + reportYear + ' - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: 'Monthly report for ' + data.projectName + '. ' + (data.description || ''),
            companyName: 'KINNOVANCE',
            sections: {
                reportPeriod: { month: monthName, year: reportYear },
                projectStatus: { health: data.health, progress: data.progress, mode: data.mode },
                stageProgress: data.stages.map(s => ({ stage: s.name, status: s.status, completion: s.completionRate || 0 })),
                tasksSummary: { total: data.tasks.length, completed: data.tasks.filter(t => t.status === 'completed').length, inProgress: data.tasks.filter(t => t.status === 'in-progress').length, pending: data.tasks.filter(t => t.status === 'pending').length },
                hoursLogged: data.totalHoursLogged,
                paymentSummary: { total: data.totalAmount, received: data.paymentSummary.received, pending: data.paymentSummary.pending },
                achievements: ['Continued development progress', 'Stage milestones tracked'],
                upcomingWork: data.stages.filter(s => s.status !== 'completed').map(s => 'Complete ' + s.name + ' stage'),
                blockers: data.tasks.filter(t => t.status === 'blocked').map(t => t.title)
            }
        }));

        return this._saveDoc(project, user, 'monthly-report', content, '📈');
    }

    // ==================== 8. STAGE SUMMARY ====================
    static async generateStageSummary(project, stageId, user) {
        const stage = project.stages.id(stageId);
        if (!stage) throw new Error('Stage not found');

        const ctx = await this._getProjectContext(project);
        const stageTasks = ctx.tasks.filter(t => t.stage === stage.name);

        ctx.currentStage = {
            name: stage.name,
            status: stage.status,
            order: stage.order,
            deadline: stage.deadline,
            completionRate: stage.completionRate,
            icon: stage.icon,
            tasksCompleted: stageTasks.filter(t => t.status === 'completed').length,
            tasksTotal: stageTasks.length,
            tasks: stageTasks
        };

        const content = await this._aiGenerate('stage-summary', 'Stage Summary: ' + stage.name, ctx, (data) => ({
            title: 'Stage Summary: ' + data.currentStage.name + ' - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: 'Stage summary for ' + data.currentStage.name + ' of ' + data.projectName + '. ' + (data.description || ''),
            companyName: 'KINNOVANCE',
            sections: {
                stageInfo: { name: data.currentStage.name, status: data.currentStage.status, deadline: data.currentStage.deadline, completion: data.currentStage.completionRate || 0 },
                taskBreakdown: { total: data.currentStage.tasksTotal, completed: data.currentStage.tasksCompleted, tasks: data.currentStage.tasks },
                deliverables: data.deliverables.filter(d => d.stage === data.currentStage.name),
                approval: { status: data.currentStage.status === 'completed' ? 'Approved' : 'Pending', approvedBy: '', approvedDate: '' },
                nextStage: data.stages.find(s => s.order === data.currentStage.order + 1) || null
            }
        }));

        return this._saveDoc(project, user, 'stage-summary', content, '📑', stage.name);
    }

    // ==================== 9. HANDOVER KIT ====================
    static async generateHandoverKit(project, user) {
        const ctx = await this._getProjectContext(project);
        const feedbacks = await Feedback.find({ project: project._id }).lean();
        ctx.feedbacks = feedbacks.map(f => ({ rating: f.rating, stage: f.stage, comments: f.comments }));

        const content = await this._aiGenerate('handover', 'Project Handover Kit', ctx, (data) => ({
            title: 'Handover Kit - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: 'Project handover documentation for ' + data.projectName + '. ' + (data.description || ''),
            companyName: 'KINNOVANCE',
            sections: {
                projectSummary: { name: data.projectName, type: data.type, startDate: data.startDate, completedDate: new Date().toISOString(), totalStages: data.stages.length, totalTasks: data.tasks.length },
                deliverables: data.deliverables.length ? data.deliverables : [{ title: 'Project deliverables as per scope', description: data.scopeOfWork }],
                accessCredentials: { hosting: 'See hosting details', repositories: 'GitHub/GitLab repository access', adminPanels: 'Admin panel credentials shared separately' },
                documentation: ['Code documentation', 'API documentation', 'User manual', 'Deployment guide'],
                feedbackSummary: {
                    totalFeedbacks: (data.feedbacks || []).length,
                    averageRating: (data.feedbacks || []).length ? ((data.feedbacks.reduce((s, f) => s + f.rating, 0)) / data.feedbacks.length).toFixed(1) : 'N/A'
                },
                maintenanceRecommendations: ['Regular backups', 'Security updates', 'Performance monitoring', 'Content updates'],
                warranty: 'Post-delivery support warranty as per agreement'
            }
        }));

        return this._saveDoc(project, user, 'handover', content, '📦');
    }

    // ==================== 10. MAINTENANCE AGREEMENT ====================
    static async generateMaintenanceAgreement(project, user) {
        const ctx = await this._getProjectContext(project);

        const content = await this._aiGenerate('maintenance-agreement', 'Maintenance and Support Agreement', ctx, (data) => ({
            title: 'Maintenance Agreement - ' + data.projectName,
            generatedDate: new Date().toISOString(),
            summary: 'Maintenance and support agreement for ' + data.projectName + '. ' + (data.description || ''),
            companyName: 'KINNOVANCE',
            sections: {
                parties: { agency: 'KINNOVANCE', client: data.clientDetails.name, company: data.clientDetails.company },
                scope: { coveredServices: ['Bug fixes', 'Security patches', 'Minor updates', 'Performance optimization', 'Server maintenance', 'Content updates (limited)'], notCovered: ['New features', 'Major redesign', 'Third-party integrations', 'Scope expansion'] },
                supportHours: { monthly: '10 hours/month', availability: 'Mon-Fri 9AM-6PM', emergencyResponse: '4 hours for critical issues', regularResponse: '24 hours for non-critical' },
                pricing: { monthly: 'As agreed', billingCycle: 'Monthly', paymentTerms: 'Net 15 days' },
                escalationMatrix: [{ level: 'L1', type: 'Minor bugs/questions', response: '24 hours' }, { level: 'L2', type: 'Functional issues', response: '12 hours' }, { level: 'L3', type: 'Critical/downtime', response: '4 hours' }],
                duration: { startDate: new Date().toISOString(), term: '12 months', renewal: 'Auto-renew unless cancelled with 30 days notice' },
                termination: 'Either party may terminate with 30 days written notice.'
            }
        }));

        return this._saveDoc(project, user, 'maintenance-agreement', content, '🔧');
    }

    // ==================== GENERATE ALL DOCUMENTS ====================
    static async generateAll(project, user) {
        const results = {};

        try { results.contract = await this.generateContract(project, user); } catch(e) { results.contractError = e.message; }
        try { results.welcomeDoc = await this.generateWelcomeDoc(project, user); } catch(e) { results.welcomeDocError = e.message; }
        try { results.paymentPlan = await this.generatePaymentPlan(project, user); } catch(e) { results.paymentPlanError = e.message; }
        try { results.clientAccessSheet = await this.generateClientAccessSheet(project, user); } catch(e) { results.clientAccessSheetError = e.message; }
        try { results.fulfillmentPlan = await this.generateFulfillmentPlan(project, user); } catch(e) { results.fulfillmentPlanError = e.message; }
        try { results.trackingSheet = await this.generateTrackingSheet(project, user); } catch(e) { results.trackingSheetError = e.message; }
        try { results.monthlyReport = await this.generateMonthlyReport(project, user); } catch(e) { results.monthlyReportError = e.message; }
        try { results.handoverKit = await this.generateHandoverKit(project, user); } catch(e) { results.handoverKitError = e.message; }
        try { results.maintenanceAgreement = await this.generateMaintenanceAgreement(project, user); } catch(e) { results.maintenanceAgreementError = e.message; }

        return results;
    }
}

module.exports = DocumentGenerator;
